const fs = require('fs');
const {parse: parsePath} = require('path-to-regexp');
const {codeSchemaToString} = require('../annotations/response');

module.exports = function openApi(endpoints, path) {
	const stream = fs.createWriteStream(path);

	const p = new Promise(function (done, fail) {
		stream.on('finish', done);
		stream.on('error', fail);
	});

	const paths = {};
	const components = {};
	const schemas = components.schemas = {};

	for (const e of endpoints) {
		const parameters = [];

		const url = parsePath(e.url.path)
		.map(function (item) {
			if (typeof item === 'string') return item;

			var param = {
				name: item.name,
				in: 'path',
				required: item.modifier === '+' || !item.modifier
			}

			if (typeof item.name === 'number') {
				param.name = 'regexp' + item.name;
				param.schema = {
					type: 'string',
					pattern: item.pattern,
				};
			}
			else if (e.params && e.params.names.includes(item.name)) {
				let {description, ...schema} = e.params.schema.properties[item.name];
				param.description = description;
				param.schema = schema;
			}

			parameters.push(param);

			return item.prefix + '{' + param.name + '}' + item.suffix;
		})
		.join('');

		let path = paths[url];

		if (!path) {
			path = paths[url] = {
				parameters: []
			};
		}

		if (parameters.length > 0) {
			path.parameters = path.parameters.concat(parameters);
		}

		if (e.query) {
			for (const name of e.query.names) {
				const {description, ...schema} = e.query.schema.properties[name];

				path.parameters.push({
					name,
					in: 'query',
					required: e.query.schema.required.includes(name),
					description,
					schema,
				});
			}
		}

		const method = path[e.url.method.toLowerCase()] = {};

		if (e.description) {
			method.description = e.description;
		}

		if (e.body) {
			let {title, description, ...schema} = e.body.schema;

			description = description || e.body.description;

			if (title) {
				schemas[title] = schema;
				schema = {
					'$ref': '#/components/schemas/' + title
				};
			}

			method.requestBody = {
				description,
				content: {
					'application/json': {
						schema
					}
				}
			};
		}

		if (e.response && e.response.length > 0) {
			const responses = method.responses = {};

			for (const res of e.response) {
				let {title, description, ...schema} = res.schema;

				description = description || res.description;

				if (title) {
					schemas[title] = schema;
					schema = {
						'$ref': '#/components/schemas/' + title
					};
				}

				codeSchemaToString(res.code).split(' || ').forEach(function (code) {
					responses[code.toUpperCase()] = {
						description,
						content: {
							'application/json': {
								schema
							}
						}
					};
				});
			}
		}
	}

	stream.write(JSON.stringify({
		openapi: '3.0.3',
		info: {
			title: 'Autogenerated OpenAPI'
		},
		paths,
		components,
	}, null, '\t'));

	stream.end();

	return p;
};